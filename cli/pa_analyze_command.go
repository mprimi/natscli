package cli

import (
	"errors"
	"fmt"
	"math"

	"github.com/choria-io/fisk"
	"github.com/nats-io/natscli/archive"
	"github.com/nats-io/nats-server/v2/server"
)

type PaAnalyzeCmd struct {
	archivePath string
	verbose     bool
	veryVerbose bool
}
type checkStatus int

func (s checkStatus) badge() string {
	switch s {
	case Pass:
		return "✅ PASS"
	case Fail:
		return "❌ FAIL"
	case SomeIssues:
		return "⚠️ WARN"
	case Skipped:
		return "◻️ SKIP"
	default:
		panic(s)
	}
}

const (
	Skipped checkStatus = iota
	Pass    checkStatus = iota
	Fail
	SomeIssues
)

func configurePaAnalyzeCommand(srv *fisk.CmdClause) {
	c := &PaAnalyzeCmd{}

	analyze := srv.Command("analyze", "perform checks against an archive generated by the `gather` subcommand").Action(c.analyze)
	analyze.Arg("archive_path", "path of archive to extract information from and analyze").Required().StringVar(&c.archivePath)
	analyze.Flag("verbose", "Print mid-check warnings").Hidden().BoolVar(&c.verbose)
	analyze.Flag("debug", "Print a lot of debugging information").Hidden().BoolVar(&c.veryVerbose)

}

func (cmd *PaAnalyzeCmd) analyze(_ *fisk.ParseContext) error {
	ar, err := archive.NewReader(cmd.archivePath)
	if err != nil {
		return err
	}
	defer func() {
		err := ar.Close()
		if err != nil {
			fmt.Printf("Failed to close archive reader: %s\n", err)
		}
	}()

	var checks = []struct {
		checkName string
		checkFunc func(r *archive.Reader) (checkStatus, error)
	}{
		{
			"Server health",
			cmd.checkServerHealth,
		},
		{
			"Uniform server version",
			cmd.checkServerVersions,
		},
		{
			"Slow consumers",
			cmd.checkSlowConsumers,
		},
		{
			"Memory usage",
			cmd.checkClusterMemoryUsageOutliers,
		},
		{
			"Lagging stream replicas",
			cmd.checkLaggingStreamReplicas,
		},
	}

	checkOutcomes := make([]checkStatus, len(checks))
	for i, check := range checks {
		fmt.Printf("\n--\nCheck %d/%d: %s \n", i+1, len(checks), check.checkName)
		outcome, err := check.checkFunc(ar)
		if err != nil {
			return fmt.Errorf("check '%s' error: %w", check.checkName, err)
		}
		checkOutcomes[i] = outcome

		fmt.Printf("%s - %s\n--\n", outcome.badge(), check.checkName)
	}

	return nil
}

// checkServerVersions ensures all servers discovered are running the same version
func (cmd *PaAnalyzeCmd) checkServerVersions(r *archive.Reader) (checkStatus, error) {
	var (
		serverTags           = r.ListServerTags()
		versionsToServersMap = make(map[string][]string)
		versionsList         = make([]string, 0)
	)

	artifactType := archive.TagServerVars()
	outcome := Pass

	for _, serverTag := range serverTags {
		serverName := serverTag.Value
		var serverVarz server.Varz

		err := r.Load(&serverVarz, &serverTag, artifactType)
		if errors.Is(err, archive.ErrNoMatches) {
			cmd.logWarning("Artifact 'VARZ' is missing for server %s", serverName)
			continue
		} else if err != nil {
			return Skipped, fmt.Errorf("failed to load variables for server %s: %w", serverTag.Value, err)
		}

		version := serverVarz.Version

		_, exists := versionsToServersMap[version]
		if !exists {
			versionsToServersMap[version] = []string{}
			versionsList = append(versionsList, version)
		}
		versionsToServersMap[version] = append(versionsToServersMap[version], serverName)
	}

	if len(versionsList) == 1 {
		cmd.logInfo("All servers are running version %s", versionsList[0])
	} else {
		cmd.logIssue("Servers are running %d different versions", len(versionsList))
		for version, serverNames := range versionsToServersMap {
			fmt.Printf("  - %s -> %d servers\n", version, len(serverNames))
		}
	}

	return outcome, nil
}

func (cmd *PaAnalyzeCmd) checkServerHealth(r *archive.Reader) (checkStatus, error) {
	serverTags := r.ListServerTags()
	artifactType := archive.TagHealth()
	notHealthy, healthy := 0, 0

	for _, serverTag := range serverTags {
		serverName := serverTag.Value
		var health server.HealthStatus

		err := r.Load(&health, &serverTag, artifactType)
		if errors.Is(err, archive.ErrNoMatches) {
			cmd.logWarning("Artifact 'HEALTHZ' is missing for server %s", serverName)
			continue
		} else if err != nil {
			return Skipped, fmt.Errorf("failed to load health for server %s: %w", serverName, err)
		}

		if health.Status != "ok" {
			cmd.logAlert("Server %s is not healthy: %+v", serverName, health)
			notHealthy += 1
		} else {
			healthy += 1
		}
	}

	if notHealthy > 0 {
		cmd.logIssue("%d/%d servers are not healthy", notHealthy, healthy+notHealthy)
		return SomeIssues, nil
	}

	cmd.logInfo("%d/%d servers are healthy", healthy, healthy)
	return Pass, nil
}

// checkSlowConsumers alerts for any slow consumer found on any server
func (cmd *PaAnalyzeCmd) checkSlowConsumers(r *archive.Reader) (checkStatus, error) {
	serverTags := r.ListServerTags()
	totalSlowConsumers := int64(0)
	serversWithSlowConsumers := make(map[string]int64)

	for _, serverTag := range serverTags {
		serverName := serverTag.Value
		var serverVarz server.Varz
		err := r.Load(&serverVarz, &serverTag, archive.TagServerVars())
		if err != nil {
			return Skipped, fmt.Errorf("failed to load Varz for server %s: %w", serverName, err)
		}

		if slowConsumers := serverVarz.SlowConsumers; slowConsumers > 0 {
			serversWithSlowConsumers[serverName] = slowConsumers
			cmd.logAlert("%s: %d slow consumers", serverName, slowConsumers)
			totalSlowConsumers += slowConsumers
		}
	}

	if totalSlowConsumers > 0 {
		cmd.logIssue("Total slow consumers: %d over %d servers", totalSlowConsumers, len(serversWithSlowConsumers))
		return SomeIssues, nil
	}
	return Pass, nil
}

const checkClusterMemoryUsageOutlierThreshold = 0.5 // Warn if one node is using over 1.5x the average
// checkClusterMemoryUsageOutliers iterates over clusters and checks whether any of the server memory usage is
// significantly higher than the cluster average.
func (cmd *PaAnalyzeCmd) checkClusterMemoryUsageOutliers(r *archive.Reader) (checkStatus, error) {

	typeTag := archive.TagServerVars()
	clusterNames := r.GetClusterNames()

	clustersWithIssuesMap := make(map[string]interface{}, len(clusterNames))

	for _, clusterName := range clusterNames {
		clusterTag := archive.TagCluster(clusterName)

		serverNames := r.GetClusterServerNames(clusterName)
		clusterMemoryUsageMap := make(map[string]float64, len(serverNames))
		clusterMemoryUsageTotal := float64(0)
		numServers := 0 // cannot use len(serverNames) as some artifacts may be missing

		for _, serverName := range serverNames {
			serverTag := archive.TagServer(serverName)

			var serverVarz server.Varz
			err := r.Load(&serverVarz, clusterTag, serverTag, typeTag)
			if errors.Is(err, archive.ErrNoMatches) {
				cmd.logWarning("Artifact 'VARZ' is missing for server %s in cluster %s", serverName, clusterName)
				continue
			} else if err != nil {
				return Skipped, fmt.Errorf("failed to load VARZ for server %s in cluster %s: %w", serverName, clusterName, err)
			}

			numServers += 1
			clusterMemoryUsageMap[serverTag.Value] = float64(serverVarz.Mem)
			clusterMemoryUsageTotal += float64(serverVarz.Mem)
		}

		clusterMemoryUsageMean := clusterMemoryUsageTotal / float64(numServers)
		threshold := clusterMemoryUsageMean + (clusterMemoryUsageMean * checkClusterMemoryUsageOutlierThreshold)

		for serverName, serverMemoryUsage := range clusterMemoryUsageMap {
			if serverMemoryUsage > threshold {
				cmd.logAlert(
					"Server %s using %s of memory, %.0f%% above cluster %s average: %s",
					serverName,
					fiBytes(uint64(serverMemoryUsage)),
					checkClusterMemoryUsageOutlierThreshold*100,
					clusterName,
					fiBytes(uint64(clusterMemoryUsageMean)),
				)
				clustersWithIssuesMap[clusterName] = nil
			}
		}
	}

	if len(clustersWithIssuesMap) > 0 {
		cmd.logIssue(
			"Clusters with at least one node using %.0f%% more memory than average: %d",
			checkClusterMemoryUsageOutlierThreshold*100,
			len(clustersWithIssuesMap),
		)
		return SomeIssues, nil
	}
	return Pass, nil
}

const checkLaggingStreamReplicasThreshold = 0.1 // Warn if a replica is 10% behind the maximum in group
// checkLaggingStreamReplicas inspects all streams and checks that no replica is behind (in number of messages and
// number of bytes) compared to the rest of the ensemble
func (cmd *PaAnalyzeCmd) checkLaggingStreamReplicas(r *archive.Reader) (checkStatus, error) {

	typeTag := archive.TagStreamDetails()
	accountNames := r.GetAccountNames()

	if len(accountNames) == 0 {
		cmd.logInfo("No accounts found in archive")
	}

	accountsWithStreams := make(map[string]interface{})
	streamsInspected := make(map[string]interface{})
	streamsWithLaggingReplicas := 0

	for _, accountName := range accountNames {
		accountTag := archive.TagAccount(accountName)
		streamNames := r.GetAccountStreamNames(accountName)

		if len(streamNames) == 0 {
			cmd.logDebug("No streams found in account: %s", accountName)
		}

		for _, streamName := range streamNames {

			// Track accounts with at least one streams
			accountsWithStreams[accountName] = nil

			streamTag := archive.TagStream(streamName)
			serverNames := r.GetStreamServerNames(accountName, streamName)

			cmd.logDebug(
				"Inspecting account '%s' stream '%s', found %d servers: %v",
				accountName,
				streamName,
				len(serverNames),
				serverNames,
			)

			// Create map server->streamDetails
			replicasStreamDetails := make(map[string]*server.StreamDetail, len(serverNames))
			streamIsEmpty := true

			for _, serverName := range serverNames {
				serverTag := archive.TagServer(serverName)
				streamDetails := &server.StreamDetail{}
				err := r.Load(streamDetails, accountTag, streamTag, serverTag, typeTag)
				if errors.Is(err, archive.ErrNoMatches) {
					cmd.logWarning(
						"Artifact not found: %s for stream %s in account %s by server %s",
						typeTag.Value,
						streamName,
						accountName,
						serverName,
					)
					continue
				} else if err != nil {
					return Skipped, fmt.Errorf("failed to lookup stream artifact: %w", err)
				}

				if streamDetails.State.Msgs > 0 {
					streamIsEmpty = false
				}

				replicasStreamDetails[serverName] = streamDetails
				// Track streams with least one artifact
				streamsInspected[accountName+"/"+streamName] = nil
			}

			// Check that all replicas are not too far behind the replica with the highest message & byte count
			if !streamIsEmpty {
				// Find the highest number of bytes and messages
				maxBytes, maxBytesServer := uint64(0), ""
				maxMessages, maxMessagesServer := uint64(0), ""
				for serverName, streamDetail := range replicasStreamDetails {
					streamState := streamDetail.State
					if streamState.Bytes > maxBytes {
						maxBytes, maxBytesServer = streamState.Bytes, serverName
					}
					if streamState.Msgs > maxMessages {
						maxMessages, maxMessagesServer = streamState.Msgs, serverName
					}
				}
				cmd.logDebug(
					"Stream %s / %s highest messages: %d @ %s",
					accountName,
					streamName,
					maxMessages,
					maxMessagesServer,
				)
				cmd.logDebug(
					"Stream %s / %s max bytes: %s @ %s",
					accountName,
					streamName,
					fiBytes(maxBytes),
					maxBytesServer,
				)

				// Check if some server's bytes or messages is below warning threshold
				minBytes := uint64(math.Max(0, float64(maxBytes)-(float64(maxBytes)*checkLaggingStreamReplicasThreshold)))
				minMessages := uint64(math.Max(0, float64(maxMessages)-(float64(maxMessages)*checkLaggingStreamReplicasThreshold)))
				isBehind := false
				for serverName, streamDetail := range replicasStreamDetails {
					messages, bytes := streamDetail.State.Msgs, streamDetail.State.Bytes
					if messages <= minMessages {
						isBehind = true
						cmd.logAlert(
							"[%s/%s] %s messages count (%d) is more than %.0f%% behind highest in group (%d)",
							accountName,
							streamName,
							serverName,
							messages,
							checkLaggingStreamReplicasThreshold*100,
							maxMessages,
						)
					}
					if bytes <= minBytes {
						isBehind = true
						cmd.logAlert(
							"[%s/%s] %s bytes count (%d) is more than %.0f%% behind highest in group (%d)",
							accountName,
							streamName,
							serverName,
							bytes,
							checkLaggingStreamReplicasThreshold*100,
							maxBytes,
						)
					}
				}
				if isBehind {
					streamsWithLaggingReplicas += 1
				}
			}
		}
	}

	cmd.logInfo("Inspected %d streams across %d accounts", len(streamsInspected), len(accountsWithStreams))

	if streamsWithLaggingReplicas > 0 {
		cmd.logIssue("Found %d streams with replicas are lagging behind", streamsWithLaggingReplicas)
		return SomeIssues, nil
	}

	return Pass, nil
}

// logSevereIssue for serious problems that need to be addressed
func (cmd *PaAnalyzeCmd) logSevereIssue(format string, a ...any) {
	fmt.Printf("‼️  "+format+"\n", a...)
}

// logIssue for issues that need attention that need to be addressed
func (cmd *PaAnalyzeCmd) logIssue(format string, a ...any) {
	fmt.Printf("❗️ "+format+"\n", a...)
}

// logAlert for more fine-grained and smaller issues (may be turned off by default)
func (cmd *PaAnalyzeCmd) logAlert(format string, a ...any) {
	if cmd.verbose || cmd.veryVerbose {
		fmt.Printf("🔔  "+format+"\n", a...)
	}
}

// logInfo for neutral and positive messages
func (cmd *PaAnalyzeCmd) logInfo(format string, a ...any) {
	fmt.Printf("ℹ️  "+format+"\n", a...)
}

// logWarning for issues running the check itself, but not serious enough to terminate with an error
func (cmd *PaAnalyzeCmd) logWarning(format string, a ...any) {
	fmt.Printf("⚠️  "+format+"\n", a...)
}

// logDebug for very fine grained progress, disabled by default
func (cmd *PaAnalyzeCmd) logDebug(format string, a ...any) {
	if cmd.veryVerbose {
		fmt.Printf("🔬  "+format+"\n", a...)
	}
}
