package cli

import (
	"errors"
	"fmt"

	"github.com/choria-io/fisk"
	"github.com/mprimi/natscli/archive"
	"github.com/nats-io/nats-server/v2/server"
)

const (
	clusterMemoryUsageThresholdPercentage = 0.6
)

type PaAnalyzeCmd struct {
	archivePath string
}

type checkFunc func(r *archive.Reader) error

var checks = []checkFunc{
	checkServerVersions,
	checkSlowConsumers,
	checkClusterMemoryUsage,
	checkStreamConsistency,
}

func configurePaAnalyzeCommand(srv *fisk.CmdClause) {
	c := &PaAnalyzeCmd{}

	analyze := srv.Command("analyze", "analyze and check for issues based on archive generated by the `gather` subcmd").Action(c.analyze)
	analyze.Arg("archivePath", "path of archive to extract information from and analyze").Required().StringVar(&c.archivePath)
}

func (c *PaAnalyzeCmd) analyze(_ *fisk.ParseContext) error {
	ar, err := archive.NewReader(c.archivePath)
	if err != nil {
		return err
	}
	defer ar.Close()

	for _, checkFunc := range checks {
		err := checkFunc(ar)
		if err != nil {
			return err
		}
	}

	return nil
}

func checkServerVersions(r *archive.Reader) error {
	var (
		serverTags           = r.ListServerTags()
		serverVersions       = make([]string, 0)
		versionsToServersMap = make(map[string][]string, len(serverTags))
	)

	for _, serverTag := range serverTags {
		serverVarz := server.Varz{}
		r.Load(&serverVarz, &serverTag, archive.TagServerVars())
		_, exists := versionsToServersMap[serverVarz.Version]
		if !exists {
			versionsToServersMap[serverVarz.Version] = []string{}
			serverVersions = append(serverVersions, serverVarz.Version)
		}
		versionsToServersMap[serverVarz.Version] = append(versionsToServersMap[serverVarz.Version], serverTag.Value)
	}

	if len(serverVersions) == 1 {
		fmt.Printf("âœ… All servers are running version %s\n", serverVersions[0])
	} else {
		fmt.Printf("ğŸ”” Warning: Servers are running %d different versions\n", len(serverVersions))
		for version, servers := range versionsToServersMap {
			fmt.Printf("  %s: %v servers\n", version, servers)
		}
	}

	return nil
}

func checkSlowConsumers(r *archive.Reader) error {
	serverTags := r.ListServerTags()
	totalSlowConsumers := int64(0)
	for _, serverTag := range serverTags {
		serverVarz := server.Varz{}
		r.Load(&serverVarz, &serverTag, archive.TagServerVars())
		if serverVarz.SlowConsumers > 0 {
			fmt.Printf("ğŸ”” Warning: %v slow consumers on server %v\n", serverVarz.SlowConsumers, serverTag.Value)
		}
		totalSlowConsumers += serverVarz.SlowConsumers
	}

	if totalSlowConsumers == 0 {
		fmt.Println("âœ… No slow consumers found")
	}
	return nil
}

func checkClusterMemoryUsage(r *archive.Reader) error {
	serverTags := r.ListServerTags()
	serversOk, serversNotOk := 0, 0
	for _, clusterTag := range r.ListClusterTags() {
		cluster := clusterTag.Value
		clusterMemoryUsage := make(map[string]float64, len(serverTags))
		totalMemory := float64(0)
		numServers := 0
		for _, serverTag := range serverTags {
			serverVarz := server.Varz{}
			err := r.Load(&serverVarz, &clusterTag, &serverTag, archive.TagServerVars())
			if errors.Is(err, archive.ErrNoMatches) {
				continue
			} else if err != nil {
				return fmt.Errorf("failed to load VARZ for server %s in cluster %s: %w", serverTag.Value, cluster, err)
			}
			clusterMemoryUsage[serverTag.Value] = float64(serverVarz.Mem)
			totalMemory += float64(serverVarz.Mem)
			numServers += 1
		}

		meanMemoryUsage := totalMemory / float64(numServers)
		threshold := meanMemoryUsage + (meanMemoryUsage * clusterMemoryUsageThresholdPercentage)
		fmt.Printf("â„¹ï¸ Cluster: %s average memory usage: %.2f MiB\n", cluster, meanMemoryUsage/(1024*1024))

		for serverName, mem := range clusterMemoryUsage {
			if mem > threshold {
				fmt.Printf(
					"ğŸ”” server: %s in cluster %s memory usage: %.2f MiB is >%.0f%% above cluster mean usage: %.2f MiB\n",
					serverName,
					cluster,
					mem/(1024*1024),
					clusterMemoryUsageThresholdPercentage*100,
					meanMemoryUsage/(1024*1024),
				)
				serversNotOk += 1
			} else {
				serversOk += 1
			}
		}
	}
	icon := "âœ…"
	if serversNotOk > 0 {
		icon = "âŒ"
	}
	fmt.Printf("%s Found %d/%d servers with high memory usage (compared to cluster average)\n", icon, serversNotOk, serversOk+serversNotOk)

	return nil
}

func checkStreamConsistency(r *archive.Reader) error {
	type streamConsistencyData struct {
		stream      string
		serverId    string
		numMessages uint64
		bytes       uint64
		leader      string
		replicas    []*server.PeerInfo
	}

	consistentCount, inconsistentCount := 0, 0

	for _, accountTag := range r.ListAccountTags() {
		for _, streamTag := range r.ListStreamTags() {
			streams := make(map[string]streamConsistencyData)
			streamConsistent := true

			for _, serverTag := range r.ListServerTags() {
				streamDetail := server.StreamDetail{}
				if err := r.Load(&streamDetail, &accountTag, &serverTag, &streamTag); err != nil {
					if errors.Is(err, archive.ErrNoMatches) {
						continue
					}
					return err
				}
				streams[serverTag.Value] = streamConsistencyData{
					stream:      streamDetail.Name,
					serverId:    serverTag.Value,
					numMessages: streamDetail.State.Msgs,
					bytes:       streamDetail.State.Bytes,
					leader:      streamDetail.Cluster.Leader,
					replicas:    streamDetail.Cluster.Replicas,
				}
			}

			var (
				bytes  uint64
				leader string
			)

			// check if all replicas are current
			for sourceServer, stream := range streams {
				for _, replica := range stream.replicas {
					if !replica.Current {
						fmt.Printf("ğŸ”” Warning: replica %s thinks that replica %s is not current on stream %s\n", sourceServer, replica.Name, stream.stream)
						streamConsistent = false
					}
				}
			}

			// check if all streams have the same bytes
			// TODO: add tolerances
			for _, stream := range streams {
				if bytes == 0 {
					bytes = stream.bytes
				}
				if bytes != stream.bytes {
					fmt.Printf("ğŸ”” Warning: stream: %v has different bytes across servers\n", stream.stream)
					streamConsistent = false
					break
				}
			}
			// check if leader is consistent
			for _, stream := range streams {
				if leader == "" {
					leader = stream.leader
				}
				if leader != stream.leader {
					fmt.Printf("ğŸ”” Warning: stream: %v has different leaders across servers\n", stream.stream)
					for _, stream := range streams {
						fmt.Printf("server: %v, leader: %v\n", stream.serverId, stream.leader)
					}
					streamConsistent = false
					break
				}
			}

			if streamConsistent {
				consistentCount += 1
			} else {
				inconsistentCount += 1
			}
		}
	}

	icon := "âœ…"
	if inconsistentCount > 0 {
		icon = "âŒ"
	}
	fmt.Printf("%s Found %d/%d streams with potential issues\n", icon, inconsistentCount, inconsistentCount+consistentCount)
	return nil
}
